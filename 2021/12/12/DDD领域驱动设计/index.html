<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="什么是领域驱动设计DDD（Domain Driven Design，领域驱动设计）是一种以领域模型作为设计基础的开发方法，通过无限接近真实世界的领域模型，来帮助我们设计高质量的软件模型。 为什么要用领域驱动设计软件发展的规律就是逐步由简单软件向复杂软件转变，当软件变得复杂时，代码就会越来越臃肿，不易维护，也就是软件退化 123我们在做软件开发设计时要遵循一个原则：开放-封闭原则（OCP）1、开放原">
<meta property="og:type" content="article">
<meta property="og:title" content="Domain Driven Design：领域驱动设计">
<meta property="og:url" content="http://chenshinan.github.io/2021/12/12/DDD领域驱动设计/index.html">
<meta property="og:site_name" content="大艺术家_SN">
<meta property="og:description" content="什么是领域驱动设计DDD（Domain Driven Design，领域驱动设计）是一种以领域模型作为设计基础的开发方法，通过无限接近真实世界的领域模型，来帮助我们设计高质量的软件模型。 为什么要用领域驱动设计软件发展的规律就是逐步由简单软件向复杂软件转变，当软件变得复杂时，代码就会越来越臃肿，不易维护，也就是软件退化 123我们在做软件开发设计时要遵循一个原则：开放-封闭原则（OCP）1、开放原">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211212205952.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214235649.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214235602.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211212213215.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211212213324.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213233856.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213234852.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213234927.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213235047.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214004344.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214233343.png">
<meta property="og:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214233712.png">
<meta property="og:updated_time" content="2022-01-02T18:26:01.844Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Domain Driven Design：领域驱动设计">
<meta name="twitter:description" content="什么是领域驱动设计DDD（Domain Driven Design，领域驱动设计）是一种以领域模型作为设计基础的开发方法，通过无限接近真实世界的领域模型，来帮助我们设计高质量的软件模型。 为什么要用领域驱动设计软件发展的规律就是逐步由简单软件向复杂软件转变，当软件变得复杂时，代码就会越来越臃肿，不易维护，也就是软件退化 123我们在做软件开发设计时要遵循一个原则：开放-封闭原则（OCP）1、开放原">
<meta name="twitter:image" content="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211212205952.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":5,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "2e062b52"
    });
  daovoice('update');
  </script>




  <link rel="canonical" href="http://chenshinan.github.io/2021/12/12/DDD领域驱动设计/">





  <title>Domain Driven Design：领域驱动设计 | 大艺术家_SN</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大艺术家_SN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">事在人为，为者终成，生死之外又有什么是一定办不到的呢</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chenshinan.github.io/2021/12/12/DDD领域驱动设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenshinan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大艺术家_SN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Domain Driven Design：领域驱动设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-12T20:03:38+08:00">
                2021-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                
                  <span class="post-meta-item-text">字数统计 </span>
                
                <span title="字数统计">
                  6.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                
                  <span class="post-meta-item-text">阅读时长 </span>
                
                <span title="阅读时长">
                  21 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="什么是领域驱动设计"><a href="#什么是领域驱动设计" class="headerlink" title="什么是领域驱动设计"></a>什么是领域驱动设计</h2><p>DDD（Domain Driven Design，领域驱动设计）是一种以领域模型作为设计基础的开发方法，通过无限接近真实世界的领域模型，来帮助我们设计高质量的软件模型。</p>
<h2 id="为什么要用领域驱动设计"><a href="#为什么要用领域驱动设计" class="headerlink" title="为什么要用领域驱动设计"></a>为什么要用领域驱动设计</h2><p>软件发展的规律就是逐步由简单软件向复杂软件转变，当软件变得复杂时，代码就会越来越臃肿，不易维护，也就是软件退化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们在做软件开发设计时要遵循一个原则：开放-封闭原则（OCP）</span><br><span class="line">1、开放原则：对于功能扩展是开放的，即当系统需求发生变更时，可以对软件功能进行扩展，使其满足用户新的需求</span><br><span class="line">2、封闭原则：对于软件代码的修改是封闭的，即在修改软件的同时，不要影响到系统原有的功能</span><br></pre></td></tr></table></figure>
<h3 id="软件退化的根源"><a href="#软件退化的根源" class="headerlink" title="软件退化的根源"></a>软件退化的根源</h3><ul>
<li>软件的本质是对真实世界的模拟，当我们只以需求/功能角度设计开发时，代码就会越来越难以理解</li>
<li>软件要做成什么样，是由真实世界决定的</li>
</ul>
<h3 id="杜绝软件退化的利器：两顶帽子"><a href="#杜绝软件退化的利器：两顶帽子" class="headerlink" title="杜绝软件退化的利器：两顶帽子"></a>杜绝软件退化的利器：两顶帽子</h3><ul>
<li>在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能</li>
<li>实现新的功能</li>
</ul>
<p>反复重构代码，在经历了多次变更后就容易迷失方向，那应该如何重构代码而不迷失方向，答案就是：<code>利用领域驱动设计，真实世界是什么样的，那么软件世界就怎么设计</code></p>
<h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>那么我们如何定义领域模型呢？首先我们知道好的软件设计常常遵循<strong>单一职责原则</strong>：软件系统中的每个元素只完成自己职责范围内的事，而将其他的事交给别人去做，我只是去调用。一个职责就是软件变化的一个原因。</p>
<ul>
<li>当“付款”发生变更时，“折扣”是不是一定要变</li>
<li>当“折扣”发生变更时，“付款”是不是一定要变</li>
</ul>
<p>答案不言而喻，因此“付款”和“折扣”是软件变化的两个原因，是两个职责，也是两个领域模型</p>
<h3 id="领域模型的最终落地是三种类型的对象：服务、实体和值对象"><a href="#领域模型的最终落地是三种类型的对象：服务、实体和值对象" class="headerlink" title="领域模型的最终落地是三种类型的对象：服务、实体和值对象"></a>领域模型的最终落地是三种类型的对象：服务、实体和值对象</h3><ul>
<li>服务（Service）：标识的是在领域对象之外的操作与行为，接收用户的请求和执行某些操作</li>
<li>实体（Entity）：通过一个唯一标识字段来区分真实世界中的每一个个体的领域对象</li>
<li>值对象：代表真实世界中那些一成不变的、本质性的事物（可变性是实体的特点，不变性是值对象的本质）</li>
</ul>
<h3 id="设计思路有两种：贫血模型和充血模型"><a href="#设计思路有两种：贫血模型和充血模型" class="headerlink" title="设计思路有两种：贫血模型和充血模型"></a>设计思路有两种：贫血模型和充血模型</h3><ul>
<li>贫血模型：就是在软件设计中，有很多的POJO对象，它们除了有一堆get/set方法，几乎没有任何业务逻辑（贫血模型更容易应对复杂的业务处理场景）</li>
<li>充血模型：领域对象中既包括状态，又包括行为及相关业务逻辑，是最符合面向对象的设计方式</li>
</ul>
<p><strong>最佳实践</strong>：将需要封装的业务逻辑放到领域对象中，按照充血模型去设计；除此之外的其他业务逻辑放到Service中，按照贫血模型去设计。所有增删改操作应当遵循领域驱动设计的思想进行设计，所有的查询功能应当直接采用sql进行查询</p>
<p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211212205952.png" alt="image"></p>
<h3 id="聚合与聚合根"><a href="#聚合与聚合根" class="headerlink" title="聚合与聚合根"></a>聚合与聚合根</h3><ul>
<li>聚合：表达的是真实世界中整体和部分的关系，当整体不存在时，则部分就没有意义。（订单与用户的关系就不是聚合关系）</li>
<li>聚合根：是外部访问的唯一入口，当有了整体和部分时，整体就是聚合根。（一般来说领域设计面向增删改的设计，查询是不受领域的限制）</li>
</ul>
<h3 id="仓库（Repository）与工厂（Factory）"><a href="#仓库（Repository）与工厂（Factory）" class="headerlink" title="仓库（Repository）与工厂（Factory）"></a>仓库（Repository）与工厂（Factory）</h3><p>通过<strong>仓库</strong>查询聚合（装载），通过<strong>工厂</strong>来补填聚合的信息，对缓存、对数据库的操作都封装在了仓库和工厂中。</p>
<ul>
<li>仓库：负责领域整体的增删改查</li>
<li>工厂：负责缓存以及填充聚合的数据</li>
</ul>
<h2 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a>领域建模</h2><p><strong>领域建模</strong>是将一个系统划分成了多个子域，每个子域都是一个独立的业务场景。每个子域的实现就是<strong>限界上下文</strong>，它们之间的关联关系是<strong>上下文地图</strong>，各个领域之间通过<strong>领域事件</strong>进行交互。</p>
<h3 id="统一语言建模与限界上下文"><a href="#统一语言建模与限界上下文" class="headerlink" title="统一语言建模与限界上下文"></a>统一语言建模与限界上下文</h3><p>在 DDD 中，一个领域被分成若干个子域，领域模型在限界上下文中完成开发。限界上下文用来为领域提供上下文语境，统一语言建模，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。</p>
<p>UL（Ubiquitous Language，通用语言）是团队共享的语言，是DDD中最具威力的特性之一。不管你在团队中的角色如何，只要你是团队的一员，你都将使用UL。由于UL的重要性，所以需要让每个概念在各自的上下文中是清晰无歧义的，于是DDD在战略设计上提出了模式BC（Bounded Context，限界上下文）。<strong>UL和BC同时构成了DDD的两大支柱</strong>，并且它们是相辅相成的，即UL都有其确定的上下文含义，而BC中的每个概念都有唯一的含义。</p>
<p>一个业务领域划分成若干个BC，它们之间通过Context Map进行集成。BC是一个显式的边界，领域模型便存在于这个边界之内。领域模型是关于某个特定业务领域的软件模型。通常，领域模型通过对象模型来实现，这些对象同时包含了数据和行为，并且表达了准确的业务含义。<br>从广义上来讲，领域即是一个组织所做的事情以及其中所包含的一切，表示整个业务系统。由于“领域模型”包含了“领域”这个词，我们可能会认为应该为整个业务系统创建一个单一的、内聚的和全功能式的模型。然而，这并不是我们使用DDD的目标。正好相反，领域模型存在于BC内。</p>
<h3 id="事件风暴会议和领域事件"><a href="#事件风暴会议和领域事件" class="headerlink" title="事件风暴会议和领域事件"></a>事件风暴会议和领域事件</h3><p>什么是事件风暴？事件即事实，即在业务领域中那些已经发生的事件就是事实。需求分析阶段，通过【统一语言建模】来指导思想，开发更进一步的理解业务，实践方法是通过【事件风暴会议】来和客户一起探讨出领域事件、领域建模等。</p>
<h3 id="常用的领域建模方法：四色建模法"><a href="#常用的领域建模方法：四色建模法" class="headerlink" title="常用的领域建模方法：四色建模法"></a>常用的领域建模方法：四色建模法</h3><p>四色建模法是在UML建模的基础上增添了一些描述，把实体分为四类，并标注不同的颜色的一种建模方法。通过还原业务逻辑事件，依据是否影响公司的运营和发展，确定凭证作为时标型对象，并补全相关描述。</p>
<p>四色建模法包括哪四色：</p>
<ul>
<li>时标型（Moment-Interval）对象：具有可追溯性的记录运营或管理数据的时刻或时段对象，用粉红色表示</li>
<li>PPT（Party/Place/Thing）对象：代表参与到流程中的参与方/地点/物，用绿色表示</li>
<li>角色（Role）对象：在时标型对象与 PPT 对象（通常是参与方）之间参与的角色，用黄色表示</li>
<li>描述（Description）对象：对 PPT 对象的一种补充描述，用蓝色表示</li>
</ul>
<p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214235649.png" alt="image"></p>
<blockquote>
<p>一句话来概括：一个什么样的人或物品以某种角色在某个时刻或某段时间内参与某个活动</p>
</blockquote>
<p>时标型对象的特点：</p>
<ul>
<li>可追溯性的记录数据</li>
<li>代表某个时间的事实</li>
<li>如果缺失会影响企业的运营和管理</li>
</ul>
<p>分析步骤：</p>
<pre><code>1.首先以满足管理和运营的需要为前提，寻找需要追溯的事件。
2.根据这些需要追溯，寻找足迹以及相应的时标性对象。
3.寻找时标性对象周围的人、事、物。
4.从中抽象角色。
5.把一些信息用描述对象补足。
</code></pre><p>一个完整的四色建模法完成品为下图所示：<br><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214235602.png" alt="image"></p>
<h2 id="深入理解DDD"><a href="#深入理解DDD" class="headerlink" title="深入理解DDD"></a>深入理解DDD</h2><h3 id="DDD的真谛"><a href="#DDD的真谛" class="headerlink" title="DDD的真谛"></a>DDD的真谛</h3><p>首先深刻理解业务，然后把我们把对业务的理解绘制成领域模型，再通过领域模型来指导程序和数据库的设计。</p>
<h3 id="基于DDD的微服务设计思路"><a href="#基于DDD的微服务设计思路" class="headerlink" title="基于DDD的微服务设计思路"></a>基于DDD的微服务设计思路</h3><p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211212213215.png" alt="image"></p>
<h3 id="DDD的整洁架构之道"><a href="#DDD的整洁架构之道" class="headerlink" title="DDD的整洁架构之道"></a>DDD的整洁架构之道</h3><p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211212213324.png" alt="image"></p>
<h2 id="DDD的三种分层架构"><a href="#DDD的三种分层架构" class="headerlink" title="DDD的三种分层架构"></a>DDD的三种分层架构</h2><p>分层架构的一个重要原则是每层只能与位于其下方的层发生耦合。分层架构的好处是显而易见的。首先，由于层间松散的耦合关系，使得我们可以专注于本层的设计，而不必关心其他层的设计，也不必担心自己的设计会影响其它层，对提高软件质量大有裨益。其次，分层架构使得程序结构清晰，升级和维护都变得十分容易，更改某层的具体实现代码，只要本层的接口保持稳定，其他层可以不必修改。即使本层的接口发生变化，也只影响相邻的上层，修改工作量小且错误可以控制，不会带来意外的风险。</p>
<p>下面介绍一下分层架构中比较经典的三种模式：</p>
<h3 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h3><p>Eric Evans在《领域驱动设计－软件核心复杂性应对之道》这本书中提出了传统的四层架构模式，如下图所示：<br><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213233856.png" alt="image"></p>
<ul>
<li>User Interface为用户界面层（或表示层），负责向用户显示信息和解释用户命令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。</li>
<li>Application为应用层，定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其它系统的应用层进行交互的必要渠道。应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。它没有反映业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度。</li>
<li>Domain为领域层（或模型层），负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心，领域模型位于这一层。</li>
<li>Infrastructure层为基础实施层，向其他层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持四个层次间的交互模式。</li>
</ul>
<p>每一层用更接地气的方式解释如下：</p>
<ul>
<li>User Interface层主要是Restful消息处理，配置文件解析，等等。</li>
<li>Application层主要是多进程管理及调度，多线程管理及调度，多协程调度和状态机管理，等等。</li>
<li>Domain层主要是领域模型的实现，包括领域对象的确立，这些对象的生命周期管理及关系，领域服务的定义，领域事件的发布，等等。</li>
<li>Infrastructure层主要是业务平台，编程框架，第三方库的封装，基础算法，等等。</li>
</ul>
<h3 id="五层架构（DCI架构）"><a href="#五层架构（DCI架构）" class="headerlink" title="五层架构（DCI架构）"></a>五层架构（DCI架构）</h3><p>James O. Coplien和Trygve Reenskaug在2009年发表了一篇论文《DCI架构：面向对象编程的新构想》，标志着DCI架构模式的诞生。面向对象编程的本意是将程序员与用户的视角统一于计算机代码之中：对提高可用性和降低程序的理解难度来说，都是一种恩赐。可是虽然对象很好地反映了结构，但在反映系统的动作方面却失败了，DCI的构想是期望反映出最终用户的认知模型中的角色以及角色之间的交互。</p>
<p>传统上，面向对象编程语言拿不出办法去捕捉对象之间的协作，反映不了协作中往来的算法。就像对象的实例反映出领域结构一样，对象的协作与交互同样是有结构的。协作与交互也是最终用户心智模型的组成部分，但你在代码中找不到一个内聚的表现形式去代表它们。在本质上，角色体现的是一般化的、抽象的算法。角色没有血肉，并不能做实际的事情，归根结底工作还是落在对象的头上，而对象本身还担负着体现领域模型的责任。</p>
<p>人们心目中对“对象”这个统一的整体却有两种不同的模型，即“系统是什么”和“系统做什么”，这就是DCI要解决的根本问题。用户认知一个个对象和它们所代表的领域，而每个对象还必须按照用户心目中的交互模型去实现一些行为，通过它在用例中所扮演的角色与其他对象联结在一起。正因为最终用户能把两种视角合为一体，类的对象除了支持所属类的成员函数，还可以执行所扮演角色的成员函数，就好像那些函数属于对象本身一样。换句话说，我们希望把角色的逻辑注入到对象，让这些逻辑成为对象的一部分，而其地位却丝毫不弱于对象初始化时从类所得到的方法。我们在编译时就为对象安排好了扮演角色时可能需要的所有逻辑。如果我们再聪明一点，在运行时才知道了被分配的角色，然后注入刚好要用到的逻辑，也是可以做到的。</p>
<p>算法及角色-对象映射由Context拥有。Context“知道”在当前用例中应该找哪个对象去充当实际的演员，然后负责把对象“cast”成场景中的相应角色（cast 这个词在戏剧界是选角的意思，此处的用词至少符合该词义，另一方面的用意是联想到cast 在某些编程语言类型系统中的含义）。在典型的实现里，每个用例都有其对应的一个Context 对象，而用例涉及到的每个角色在对应的Context 里也都有一个标识符。Context 要做的只是将角色标识符与正确的对象绑定到一起。然后我们只要触发Context里的“开场”角色，代码就会运行下去。</p>
<p>于是我们有了完整的DCI架构（Data、Context和Interactive三层架构）：</p>
<ul>
<li>Data层描述系统有哪些领域概念及其之间的关系，该层专注于领域对象的确立和这些对象的生命周期管理及关系，让程序员站在对象的角度思考系统，从而让“系统是什么”更容易被理解。</li>
<li>Context层：是尽可能薄的一层。Context往往被实现得无状态，只是找到合适的role，让role交互起来完成业务逻辑即可。但是简单并不代表不重要，显示化context层正是为人去理解软件业务流程提供切入点和主线。</li>
<li>Interactive层主要体现在对role的建模，role是每个context中复杂的业务逻辑的真正执行者，体现“系统做什么”。role所做的是对行为进行建模，它联接了context和领域对象。由于系统的行为是复杂且多变的，role使得系统将稳定的领域模型层和多变的系统行为层进行了分离，由role专注于对系统行为进行建模。该层往往关注于系统的可扩展性，更加贴近于软件工程实践，在面向对象中更多的是以类的视角进行思考设计。</li>
</ul>
<p><strong>DCI目前广泛被看作是对DDD的一种发展和补充，用在基于面向对象的领域建模上。显式的对role进行建模，解决了面向对象建模中的充血模型和贫血模型之争。DCI通过显式的用role对行为进行建模，同时让role在context中可以和对应的领域对象进行绑定(cast)，从而既解决了数据边界和行为边界不一致的问题，也解决了领域对象中数据和行为高内聚低耦合的问题</strong></p>
<pre><code>面向对象建模面临的一个棘手问题是数据边界和行为边界往往不一致。遵循模块化的思想，我们通过类将行为和其紧密耦合的数据封装在一起。但是在复杂的业务场景下，行为往往跨越多个领域对象，这样的行为如果放在某一个对象中必然会导致别的对象需要向该对象暴漏其内部状态。所以面向对象发展的后来，领域建模出现两种派别之争，一种倾向于将跨越多个领域对象的行为建模在领域服务中。如果这种做法使用过度，则会导致领域对象变成只提供一堆get方法的哑对象，这种建模结果被称之为贫血模型。而另一派则坚定的认为方法应该属于领域对象，所以所有的业务行为仍然被放在领域对象中，这样导致领域对象随着支持的业务场景变多而变成上帝类，而且类内部方法的抽象层次很难一致。另外由于行为边界很难恰当，导致对象之间数据访问关系也比较复杂，这种建模结果被称之为充血模型。
</code></pre><p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213234852.png" alt="image"></p>
<p>引入DCI后，DDD四层架构模式中的Domain层变薄了，以前Domain层对应DCI中的三层，而现在：</p>
<ul>
<li><p>Domain层只保留了DCI中的Data层和Interaction层，我们在实践中通常将这两层使用目录隔离，即通过两个目录object和role来分离层Data和Interaction。</p>
<p>  <img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213234927.png" alt="image"></p>
</li>
<li><p>DCI中的Context层从Domain层上移变成Context层。</p>
</li>
</ul>
<p>因此，DDD分层架构模式就变成了五层，如下图所示：</p>
<p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211213235047.png" alt="image"></p>
<p>每一层用更接地气的方式解释如下：</p>
<ul>
<li>User Interface是用户接口层，主要用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给Application层的接口。</li>
<li>Application层是应用层，负责多进程管理及调度、多线程管理及调度、多协程调度和维护业务实例的状态模型。当调度层收到用户接口层的请求后，委托Context层与本次业务相关的上下文进行处理。</li>
<li>Context是环境层，以上下文为单位，将Domain层的领域对象cast成合适的role，让role交互起来完成业务逻辑。</li>
<li>Domain层是领域层，定义领域模型，不仅包括领域对象及其之间关系的建模，还包括对象的角色role的显式建模。</li>
<li>Infrastructure层是基础实施层，为其他层提供通用的技术能力：业务平台，编程框架，持久化机制，消息机制，第三方库的封装，通用算法，等等。</li>
</ul>
<h3 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h3><p>有一种方法可以改进分层架构，即依赖倒置原则(Dependency Inversion Principle, DIP)，它通过改变不同层之间的依赖关系达到改进目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">依赖倒置原则由Robert C. Martin提出，正式定义为：</span><br><span class="line">高层模块不应该依赖于底层模块，两者都应该依赖于抽象。</span><br><span class="line">抽象不应该依赖于细节，细节应该依赖于抽象。</span><br></pre></td></tr></table></figure>
<p>根据该定义，DDD分层架构中的低层组件应该依赖于高层组件提供的接口，即无论高层还是低层都依赖于抽象，整个分层架构好像被推平了。如果我们把分层架构推平，再向其中加入一些对称性，就会出现一种具有对称性特征的架构风格，即六边形架构。六边形架构是Alistair Cockburn在2005年提出的，在这种架构中，不同的客户通过“平等”的方式与系统交互。需要新的客户吗？不是问题。只需要添加一个新的适配器将客户输入转化成能被系统API所理解的参数就行。同时，对于每种特定的输出，都有一个新建的适配器负责完成相应的转化功能。</p>
<p>六边形架构又称<strong>端口适配器架构</strong>，实际上也是一种分层架构，只不过由上下或者左右变成了内部与外部。其核心理念就是应用通过端口与外部进行交互的。核心的业务逻辑（领域模型）与外部资源（数据库等资源）完全隔离，仅通过适配器进行交互，解决了业务逻辑与用户数据交错的问题，很好的实现了前后端分离。如下图所示：</p>
<p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214004344.png" alt="image"></p>
<p>六边形每条不同的边代表了不同类型的端口，端口要么处理输入，要么处理输出。对于每种外界类型，都有一个适配器与之对应，外界通过应用层API与内部进行交互。上图中有3个客户请求均抵达相同的输入端口（适配器A、B和C），另一个客户请求使用了适配器D。假设前3个请求使用了HTTP协议（浏览器、REST和SOAP等），而后一个请求使用了AMQP协议（比如RabbitMQ）。端口并没有明确的定义，它是一个非常灵活的概念。无论采用哪种方式对端口进行划分，当客户请求到达时，都应该有相应的适配器对输入进行转化，然后端口将调用应用程序的某个操作或者向应用程序发送一个事件，控制权由此交给内部区域。</p>
<p>六边形架构分为了三层：端口适配器、应用层与领域层。而端口又可以分为输入端口和输出端口，每一层用更接地气的方式解释如下：</p>
<ul>
<li><p>输入端口：用于系统提供服务时暴露API接口，接受外部客户系统的输入，并客户系统的输入转化为程序内部所能理解的输入。系统作为服务提供者是对外的接入层可以看成是输入端口。</p>
</li>
<li><p>输出端口：为系统获取外部服务提供支持，如获取持久化状态、对结果进行持久化，或者发布领域状态的变更通知（如领域事件）。系统作为服务的消费者获取服务是对外的接口（数据库、缓存、消息队列、RPC调用）等都可以看成是输出端口。</p>
</li>
<li><p>应用层：定义系统可以完成的工作，很薄的一层。它并不处理业务逻辑通过协调领域对象或领域服务完成业务逻辑，并通过输入端口输出结果。也可以在这一层进行事物管理。</p>
</li>
<li><p>领域层：负责表示业务概念、规则与状态，属于业务的核心。</p>
</li>
</ul>
<p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214233343.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用层与领域层的不变性可以保证核心领域不受外部的干扰，而端口的可替换性可以很方便的对接不用的外部系统。</span><br></pre></td></tr></table></figure>
<p><img src="https://csn-images.oss-cn-shenzhen.aliyuncs.com/markdown/20211214233712.png" alt="image"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.jianshu.com/p/a775836c7e25" target="_blank" rel="noopener">DDD分层架构的三种模式</a></li>
<li><a href="https://www.jianshu.com/p/c405aa19a049" target="_blank" rel="noopener">DDD 领域驱动设计学习（四）- 架构（分层/六边形/RESTful）</a></li>
<li><a href="https://www.jianshu.com/p/85630cf2cd13" target="_blank" rel="noopener">Golang领域模型-六边形架构（包含如何建目录结构）</a></li>
<li><a href="https://www.pianshen.com/article/5129944876/" target="_blank" rel="noopener">六边形架构认识（包含如何建目录结构）</a></li>
<li><a href="https://www.jianshu.com/p/513b021ad283" target="_blank" rel="noopener">运用四色建模法进行领域分析（举例）</a></li>
<li><a href="https://www.pianshen.com/article/7874968222/" target="_blank" rel="noopener">领域驱动设计中的四色建模法（概念）</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/12/09/快捷记忆/" rel="next" title="快捷记忆">
                <i class="fa fa-chevron-left"></i> 快捷记忆
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/01/03/从0到1搭建web系统（一）/" rel="prev" title="从0到1搭建web系统（一）">
                从0到1搭建web系统（一） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="chenshinan">
            
              <p class="site-author-name" itemprop="name">chenshinan</p>
              <p class="site-description motion-element" itemprop="description">Painting talent persisted in playing music, but also dreamed of becoming a director and finally becoming a programmer's great artist.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chenshinan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是领域驱动设计"><span class="nav-number">1.</span> <span class="nav-text">什么是领域驱动设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要用领域驱动设计"><span class="nav-number">2.</span> <span class="nav-text">为什么要用领域驱动设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件退化的根源"><span class="nav-number">2.1.</span> <span class="nav-text">软件退化的根源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#杜绝软件退化的利器：两顶帽子"><span class="nav-number">2.2.</span> <span class="nav-text">杜绝软件退化的利器：两顶帽子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#领域模型"><span class="nav-number">3.</span> <span class="nav-text">领域模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#领域模型的最终落地是三种类型的对象：服务、实体和值对象"><span class="nav-number">3.1.</span> <span class="nav-text">领域模型的最终落地是三种类型的对象：服务、实体和值对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计思路有两种：贫血模型和充血模型"><span class="nav-number">3.2.</span> <span class="nav-text">设计思路有两种：贫血模型和充血模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合与聚合根"><span class="nav-number">3.3.</span> <span class="nav-text">聚合与聚合根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#仓库（Repository）与工厂（Factory）"><span class="nav-number">3.4.</span> <span class="nav-text">仓库（Repository）与工厂（Factory）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#领域建模"><span class="nav-number">4.</span> <span class="nav-text">领域建模</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#统一语言建模与限界上下文"><span class="nav-number">4.1.</span> <span class="nav-text">统一语言建模与限界上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件风暴会议和领域事件"><span class="nav-number">4.2.</span> <span class="nav-text">事件风暴会议和领域事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的领域建模方法：四色建模法"><span class="nav-number">4.3.</span> <span class="nav-text">常用的领域建模方法：四色建模法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解DDD"><span class="nav-number">5.</span> <span class="nav-text">深入理解DDD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DDD的真谛"><span class="nav-number">5.1.</span> <span class="nav-text">DDD的真谛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于DDD的微服务设计思路"><span class="nav-number">5.2.</span> <span class="nav-text">基于DDD的微服务设计思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DDD的整洁架构之道"><span class="nav-number">5.3.</span> <span class="nav-text">DDD的整洁架构之道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDD的三种分层架构"><span class="nav-number">6.</span> <span class="nav-text">DDD的三种分层架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#四层架构"><span class="nav-number">6.1.</span> <span class="nav-text">四层架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五层架构（DCI架构）"><span class="nav-number">6.2.</span> <span class="nav-text">五层架构（DCI架构）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六边形架构"><span class="nav-number">6.3.</span> <span class="nav-text">六边形架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">7.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenshinan</span>

  
</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共155.9k字</span>
</div>








        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
